[ count how many digits in any number system ]
scourge.cast.calculate.digit_count(base !scourge.cell, value !scourge.cell)(count !scourge.cell) = {
    [ check for zero value ]
    scourge.integer.within_range(scourge.constant.0, value, scourge.constant.0)(is_zero_value, is_not_zero_value)
    @is_zero_value is_zero_value = {
        [ if is zero value, then character count must be 1 to account for '0' string ]
        scourge.set(scourge.integer.1)(count)

        [ exit function ]
        scourge.jump(scourge.always, @finished)()
    }

    [ check for invalid denominator ]
    scourge.integer.within_range(scourge.constant.0, base, scourge.constant.1)(is_zero_base, is_not_zero_base)
    @is_zero_base is_zero_base = {
        [ if is zero base, then character count must be 0 to account for an invalid denominator ]
        scourge.set(scourge.integer.0)(count)

        [ exit function ]
        scourge.jump(scourge.always, @finished)()
    }

    [ calculate count ]
    [ null init count ]
    scourge.set(scourge.integer.0)(count)

    [ loop start ]
    @loop_start

    [ check if value is zero ]
    scourge.integer.within_range(scourge.constant.0, value, scourge.constant.0)(is_zero_value, is_not_zero_value)
    scourge.jump(is_zero_value, @finished)()

    [ calculate new amount ]
    scourge.integer.divide(value, base)(value)

    [ increment counter ]
    scourge.integer.add(count, scourge.constant.1)(count)

    [ jump to loop start ]
    scourge.jump(scourge.always, @loop_start)()

    [ setup exit ]
    @finished
}

[ convert a cell to a string of any type ]
scourge.cast.cell_to_text(value !scourge.cell, base !scourge.cell, digits !scourge.buffer, direction !scourge.cell[ false is lower to higher, true is higher to lower ])(string !scourge.buffer) = {
    [ calculate digit count ]
    scourge.cast.calculate.digit_count(base, value)(digit_count)

    [ allocate string ]
    scourge.buffer.request(digit_count)(string)

    [ invert direction ]
    scourge.bits.xor(direction, scourge.constant.1)(alternate_direction)

    [ if is lower to higher ]
    @lower_to_higher alternate_direction = {
        [ setup current ]
        scourge.pack(string, string:start)(current !scourge.current)

        [ setup loop start ]
        @lower_to_higher.loop_start

        [ check for valid current ]
        scourge.current.within_range(current)(continue, exit)
        scourge.jump(exit, @exit)()

        [ get digit ]
        scourge.integer.modulous(value, base)(remainder)
        scourge.integer.add(digits:start, remainder)(character_address)
        scourge.address_to_cell(character_address, scourge.constant.1)(character, advancement)

        [ setup next digit ]
        scourge.integer.divide(value, base)(value)

        [ write digit ]
        scourge.cell_to_address(character, scourge.constant.1, current:progress)(advancement)

        [ advance current ]
        scourge.integer.add(current:progress, scourge.constant.1)(current:progress)

        [ jump to beginning for next character ]
        scourge.jump(scourge.always, @lower_to_higher.loop_start)()
    }

    [ if is higher to lower ]
    @higher_to_lower direction = {
        [ setup current ]
        scourge.pack(string, string:end)(current !scourge.current)

        [ setup loop start ]
        @higher_to_lower.loop_start

        [ check for valid current ]
        scourge.current.within_range(current)(continue, exit)
        scourge.jump(exit, @exit)()

        [ get digit ]
        scourge.integer.modulous(value, base)(remainder)
        scourge.integer.add(digits:start, remainder)(character_address)
        scourge.address_to_cell(character_address, scourge.constant.1)(character, advancement)

        [ setup next digit ]
        scourge.integer.divide(value, base)(value)

        [ write digit ]
        scourge.cell_to_address(character, scourge.constant.1, current:progress)(advancement)

        [ advance current ]
        scourge.integer.subtract(current:progress, scourge.constant.1)(current:progress)

        [ jump to beginning for next character ]
        scourge.jump(scourge.always, @higher_to_lower.loop_start)()
    }

    [ setup loop exit ]
    @exit
}

[ cast a cell to binary string ]
scourge.cast.cell_to_binary_string.lower_to_higher(value !scourge.cell)(string !scourge.buffer) = {
    [ setup data ]
    scourge.set("01")(digits)
    scourge.set(scourge.integer.2)(base)
    scourge.set(scourge.boolean.false)(direction)

    [ cast ]
    scourge.cast.cell_to_text(value, base, digits, direction)(string)
}

[ cast a cell to binary string ]
scourge.cast.cell_to_binary_string.higher_to_lower(value !scourge.cell)(string !scourge.buffer) = {
    [ setup data ]
    scourge.set("01")(digits)
    scourge.set(scourge.integer.2)(base)
    scourge.set(scourge.boolean.true)(direction)

    [ cast ]
    scourge.cast.cell_to_text(value, base, digits, direction)(string)
}

[ cast a cell to decimal string ]
scourge.cast.cell_to_decimal_string.lower_to_higher(value !scourge.cell)(string !scourge.buffer) = {
    [ setup data ]
    scourge.set("0123456789")(digits)
    scourge.set(scourge.integer.10)(base)
    scourge.set(scourge.boolean.false)(direction)

    [ cast ]
    scourge.cast.cell_to_text(value, base, digits, direction)(string)
}

[ cast a cell to decimal string ]
scourge.cast.cell_to_decimal_string.higher_to_lower(value !scourge.cell)(string !scourge.buffer) = {
    [ setup data ]
    scourge.set("0123456789")(digits)
    scourge.set(scourge.integer.10)(base)
    scourge.set(scourge.boolean.true)(direction)

    [ cast ]
    scourge.cast.cell_to_text(value, base, digits, direction)(string)
}

[ cast a cell to hex string ]
scourge.cast.cell_to_hex_string.lower_to_higher(value !scourge.cell)(string !scourge.buffer) = {
    [ setup data ]
    scourge.set("0123456789ABCDEF")(hexits)
    scourge.set(scourge.integer.16)(base)
    scourge.set(scourge.boolean.false)(direction)

    [ cast ]
    scourge.cast.cell_to_text(value, base, hexits, direction)(string)
}

[ cast a cell to hex string ]
scourge.cast.cell_to_hex_string.higher_to_lower(value !scourge.cell)(string !scourge.buffer) = {
    [ setup data ]
    scourge.set("0123456789ABCDEF")(hexits)
    scourge.set(scourge.integer.16)(base)
    scourge.set(scourge.boolean.true)(direction)

    [ cast ]
    scourge.cast.cell_to_text(value, base, hexits, direction)(string)
}
